## インデックス設定

### 1. インデックス設定前
employees データベースの employees テーブルに対して、誕生日が1961年8月3日のレコードを取得  
その際に、EXPLAIN ANALYZE ステートメントを利用することで、実行時間を計測  

```sql
EXPLAIN
SELECT *
FROM employees
WHERE birth_date = '1961-08-03';
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299290 |    10.00 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.11 sec)


EXPLAIN ANALYZE
SELECT *
FROM employees
WHERE birth_date = '1961-08-03';
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                                                                                                                                      |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -> Filter: (employees.birth_date = DATE'1961-08-03')  (cost=30161.25 rows=29929) (actual time=11.566..229.613 rows=67 loops=1)
    -> Table scan on employees  (cost=30161.25 rows=299290) (actual time=0.062..186.327 rows=300024 loops=1)
 |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.24 sec)
```

### 2. インデックスの作成
employees データベースの employees テーブルの birth_date カラムにインデックスを作成  

```sql
ALTER TABLE employees
ADD INDEX birth_date_index (birth_date);
Query OK, 0 rows affected (3.03 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

### 3. インデックスの確認
employees データベースの employees テーブルのインデックスを確認し、インデックスが作成されていることを確認

```sql
show index from employees;
+-----------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table     | Non_unique | Key_name         | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-----------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| employees |          0 | PRIMARY          |            1 | emp_no      | A         |      299290 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| employees |          1 | birth_date_index |            1 | birth_date  | A         |        4781 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+-----------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
2 rows in set (0.01 sec)
```

### 4. インデックスの効果の確認
1と同じクエリを実行  
その際に、EXPLAIN ANALYZE ステートメントを利用することで、実行時間を計測し、実行が高速化されていることを確認  

```sql
EXPLAIN
SELECT *
FROM employees
WHERE birth_date = '1961-08-03';
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type | possible_keys    | key              | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | ref  | birth_date_index | birth_date_index | 3       | const |   67 |   100.00 | NULL  |
+----+-------------+-----------+------------+------+------------------+------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)


EXPLAIN ANALYZE
SELECT *
FROM employees
WHERE birth_date = '1961-08-03';
+-----------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                                             |
+-----------------------------------------------------------------------------------------------------------------------------------------------------+
| -> Index lookup on employees using birth_date_index (birth_date=DATE'1961-08-03')  (cost=23.45 rows=67) (actual time=0.614..0.645 rows=67 loops=1)
 |
+-----------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
```

### 5. インデックスの説明
- インデックスを張ることでクエリが高速化された理由  
インデックスを張ることで特定の列のポインタ情報（データの場所）が作成される  
1の例では、インデックスが作成されていないため、employees テーブルの全ての行(300024行)をフルスキャンしているが  
4の例では、インデックスが作成されているため、employees テーブルの対象行(67行)へダイレクトでアクセスしている  
インデックスを張ることでポインタ情報を参照し、テーブルの特定レコードを狙い撃ちでアクセスできるためクエリが高速化された  

### 6. インデックスの削除
作成したインデックスを削除

```sql
ALTER TABLE employees
DROP INDEX birth_date_index;
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

### 7. ベストプラクティス
インデックスは作成すればするほどよいというものではなく必要な場合のみ作成することが重要
インデックス作成のベストプラクティスについて調べ、どのような方針でインデックスを貼ると良いかまとめる  

### 方針
1. 大規模なテーブルに対して作成する
2. カーティナリティの高い列に作成する
3. SQL文でWHERE句の選択条件、または結合条件に使用されている列に作成する
